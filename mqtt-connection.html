<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mqttjs.html">


<!--
The `mqtt-connection` element exposes mqtt connection functionality to the web.
Use one `<mqtt-connection>` element per connection to a mqtt broker.
Currently the element supports `ws` connections.

    <mqtt-connection
        url="ws://127.0.0.1:8080"
        options='{reconnectPeriod: 1000}'>
    </mqtt-connection>


With `auto` set to `true`, the element performs a mqtt#Connect whenever
the element is ready or the connection gets disconnected.

Note: The `options` attribute must be double quoted JSON.

You can disconnect the mqtt-connection explicitly by calling `disconnect` on the
element. And manually connect if `auto` is set to `false` with `connect`

@demo demo/index.html
-->

<dom-module id="mqtt-connection">
  <template>
    <content id="mqttSubscriptions" select="mqtt-subscription"></content>
    <content id="mqttPublications" select="mqtt-publish"></content>
    <content id="content"></content>
  </template>
</dom-module>

<script>

  'use strict';

  Polymer({
    is: 'mqtt-connection',

    /**
     * Fired when a connection is connected.
     *
     * @event mqtt-connection-connected
     */

    /**
     * Fired when a connection is reconnected.
     *
     * @event mqtt-connection-reconnected
     */

    /**
     * Fired when a connection is closed.
     *
     * @event mqtt-connection-close
     */

    /**
     * Fired when a connection is closed.
     *
     * @event mqtt-connection-offline
     */

    /**
     * Fired when a connection error occurs.
     *
     * @event mqtt-connection-error
     */

    /**
     * Fired when a mqtt message is received .
     *
     * @event mqtt-message
     */

    properties: {

      /**
       * If set to `true` with just adding `disable-auto the mqtt connection will **NOT** be established after the element is loaded.
       */
      auto: {
        type: Boolean,
        readOnly: false,
        value: false,
      },

      /**
       * Set the clean flag to `false` to receive QOS 1 and 2 messages while offline. The messages are delivered if the
       * connection is re-establish with the broker.
       */
      clean: {
        type: Boolean,
        readOnly: false,
        value: true,
      },

      /**
       * Indicates weather the mqtt client is connected to the mqtt broker or not
       */
      connected: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false,
        observer: '_connectedChanged',
      },

      /**
       * Indicates weather the mqtt client is currently disconnecting the mqtt connection or not
       */
      disconnecting: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false,
      },

      /**
       * The actual MQTT.js client that will be created on the first connect or injected
       * via `<mqtt-connection client="[[client]]">`
       */
      client: {
        type: Object,
        readOnly: false,
        notify: true,
        observer: '_clientChanged',
      },

      /**
       * The prefix of the option.clientId. If the option.clientId is not set a random ID will be generated prefixed
       * with clientIdPrefix
       */
      clientIdPrefix: {
        type: String,
        value: 'mqttjs_',
      },

      /**
       * The options are directly passed to MQTT.js
       * For further documentation see https://github.com/mqttjs/MQTT.js/wiki/connection
       * * options.protocolId :String The mqtt protocolId tha is send to the mqtt broker DEFAULT: "MQTT"
       * * options.protocolVersion :number 4
       * * options.keepalive :number 10
       * * options.clientId :String
       * * options.clean :boolean
       * * options.username :String The username that is user to authenticate the connection with
       * * options.password :String The password that will be used to authenticate the `user` at the mqtt broker
       * * options.will :Object The clients will message that is published from the mqtt broker in behalf of the client
       * if the connection is from the client to the mqtt broker is lost.
       * * options.will.topic :String The topic of the will message of the client eg. "client/"
       * * options.will.qos :number The QOS of the will message of the client
       * * options.will.retain :boolean The retain flag of the will message of the client
       */
      options: {
        type: Object,
        readOnly: false,
        notify: true,
        value: function () {
          return {
            //MQIsdp
            protocolId: "MQTT",
            protocolVersion: 4,
            keepalive: 10,
            reconnectPeriod: 1000,
            clientId: "",
            encoding: "string",
          }
        }
      },

      /**
       * The url of the mqtt broker and can be on the following protocols: 'mqtt', 'mqtts', 'tcp', 'tls', 'ws', 'wss'.
       * E.g ws://localhost:8080
       */
      url: {
        type: String,
        value: '',
      },

      subscriptions: {
        type: Array,
        value: function () {
          return [];
        }
      }
    },

//    listeners:
//    mqtt-subscription-attached

    listeners: {
      'mqtt-subscription-register': '_elementRegistered',
      'mqtt-subscription-unregister': '_elementUnregistered',
    },

    _elementRegistered: function(event){
//      console.log("_elementRegistered", arguments);
      // adding the element to the subscriptions
      this.push("subscriptions", event.target);
      // setting this connection as the parrent on the connection
      event.target._parentConnection = this;

      this._createSubscription(event.target);
    },

    _elementUnregistered: function(event){
//      console.log("_elementUnregistered", arguments);
      var target = event.detail.target;
      if (target) {
        if (target.topic){
          this.client.unsubscribe(target.topic);
        }
        var index = this.subscriptions.indexOf(target);
        if (index > -1) {
          this.splice("subscriptions", index, 1);
        }
      }
    },

    ready: function () {
    },

    attached: function () {

      this._loadMqttSubscriptions();

      if(this.auto) {
        this.connectClient();
      }
    },

    connectClient: function () {
//      console.log("connectClient");
      if(mqtt) {
        this.options.clientId = this._generateClientId();
        this.client = mqtt.connect(this.url, this.options);
      } else {
        // failed to load mqtt.js
        // TODO SKO tell the user about this and maybe log environment
        console.error("<mqtt-connection> could not load MQTT.js, pleas check your setup");
      }
    },

    _clientChanged: function (client, old) {
      if(client) {
        client
            .on("reconnect", this._handelReconnect.bind(this))
            .on("connect", this._handelConnected.bind(this))
            .on("close", this._handelClose.bind(this))
            .on("offline", this._handelOffline.bind(this))
            .on("error", this._handelError.bind(this))
            .on("message", this._handelMessage.bind(this))
      }
    },

    _getConnectionStatusofConnection: function(client){
      return client ? client.connected : false
    },

    /**
     * Generates a random mqtt client ID
     * @returns {string} the X digit mqtt client ID prefixed with 'mqttjs_'
     * @private
     */
    _generateClientId: function () {
      return this.clientIdPrefix + Math.random().toString(16).substr(2, 8);
    },

    _handelConnected: function () {
      console.log("_handelConnected");
      this._setMqttConnected(this._getConnectionStatusofConnection(this.client));
      this.fire("mqtt-connection-connected", {value: this.connected});
    },
    _handelReconnect: function () {
      this.fire("mqtt-connection-reconnect");
    },

    _handelClose: function () {
      this.fire("mqtt-connection-close");
    },

    _handelOffline: function () {
      this._setMqttConnected(this._getConnectionStatusofConnection(this.client));
      this.fire("mqtt-connection-offline", {value: this.connected});
    },

    _handelError: function () {
      this.fire("mqtt-connection-error");
    },

    _handelMessage: function (topic, message, packet) {
      this.fire("mqtt-message", {'topic': topic, 'message': message, 'packet': packet});
    },

    _setMqttConnected: function (state) {
      if(typeof state === "boolean") {
        this._setConnected(state);
      }
    },

    _connectedChanged: function (connected, old) {
      if(connected) {
//        this._createSubscriptions();
      }
    },

    _createSubscription: function(sub){
      if (this.client){
        this.client.subscribe(sub.topic, sub.qos, sub._handelSubscriptionSubscribed.bind(sub));
      }
    },

//    _createSubscriptions: function () {
//      var items = Polymer.dom(this.$.mqttSubscriptions).getDistributedNodes();
//      console.log("_loadMqttSubscriptions", this.id ,items);
//
//      if(this.subscriptions.length > 0) {
//        for (var i = 0; i < this.subscriptions.length; i++) {
//          var sub = this.subscriptions[i];
//          if(sub && sub.topic) {
////            console.log("_createSubscriptions", this.options.clientId, this.id);
//            this.client.subscribe(sub.topic, sub.qos, sub._handelSubscriptionSubscribed.bind(sub));
//          }
//        }
//      }
//    },

    _loadMqttSubscriptions: function () {
//      // TODO sandro-k validate query and refactor to forEach
//      var items = Polymer.dom(this.$.mqttSubscriptions).getDistributedNodes();
//      console.log("_loadMqttSubscriptions", this.id ,items);
//
//      for (var i = 0; i < items.length; i++) {
//        this.push("subscriptions", items[i]);
//      }

    }
  });
</script>
